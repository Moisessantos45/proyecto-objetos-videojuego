================================================================================
DOCUMENTACION CORREGIDA: FLUJO DE PANTALLAS Y MENUS
================================================================================

Este documento describe en detalle el funcionamiento, codigo y logica de las 
pantallas de interfaz, corrigiendo la version anterior para reflejar el flujo 
real y las opciones especificas del juego.

================================================================================

1. PANTALLA DE BIENVENIDA

Es la primera pantalla que se muestra al ejecutar el juego. Su proposito es 
presentar el titulo y esperar a que el jugador continue hacia el menu principal.

   1.1. Funcionamiento General

   El juego se inicia en un estado WELCOME. En este estado, la pantalla es 
   estatica y solo muestra un mensaje de bienvenida. El juego no procesa 
   ninguna logica de juego (movimiento, enemigos, etc.), solo espera una 
   unica entrada del teclado (ENTER) para cambiar al siguiente estado, que 
   es el menu principal.

   1.2. Archivos y Codigo Involucrados

   Archivo: Main/GamePanel.java
      Contiene el enum GameState que define este estado y la logica para 
      dibujarlo en paintComponent.

   Archivo: Main/ManejadorTeclas.java
      Detecta la pulsacion de ENTER para avanzar al siguiente estado.

   1.3. Logica de Estado y Renderizado

   Se necesita un GameState mas especifico para diferenciar la bienvenida 
   del menu.

   Archivo: Main/GamePanel.java
   Codigo de Estado:

      // Dentro de la clase GamePanel
      public enum GameState {
          WELCOME, // Nuevo estado para la pantalla de bienvenida
          MENU,    // Estado para el menu de opciones
          PLAY,
          PAUSE
      }
      public GameState gameState;

      // El constructor ahora inicia en el estado WELCOME
      public GamePanel() {
          // ...
          this.gameState = GameState.WELCOME;
      }

      // El metodo paintComponent gestiona que dibujar
      @Override
      public void paintComponent(Graphics g) {
          super.paintComponent(g);
          Graphics2D g2 = (Graphics2D) g;

          if (gameState == GameState.WELCOME) {
              drawWelcomeScreen(g2);
          } else if (gameState == GameState.MENU) {
              drawMenuScreen(g2);
          } // ... etc.
      }

      // Metodo especifico para dibujar la pantalla de bienvenida
      public void drawWelcomeScreen(Graphics2D g2) {
          g2.setColor(Color.BLACK);
          g2.fillRect(0, 0, screenWidth, screenHeight);
          g2.setFont(g2.getFont().deriveFont(Font.BOLD, 70F));
          String text = "Bienvenido a la Aventura";
          int x = getXforCenteredText(text, g2);
          int y = screenHeight / 2 - (tileSize  2);
          g2.setColor(Color.WHITE);
          g2.drawString(text, x, y);

          g2.setFont(g2.getFont().deriveFont(Font.PLAIN, 40F));
          text = "Presiona ENTER para continuar";
          x = getXforCenteredText(text, g2);
          y += tileSize  2;
          g2.drawString(text, x, y);
      }

   1.4. Manejo de Teclas

   En este estado, solo se escucha la tecla ENTER.

   Archivo: Main/ManejadorTeclas.java
   Codigo de Manejo de Teclas:

      // Dentro de keyPressed
      if (gp.gameState == GameState.WELCOME) {
          if (code == KeyEvent.VK_ENTER) {
              gp.gameState = GameState.MENU; // Transicion al menu principal
          }
      }

================================================================================

2. PANTALLA DE MENU PRINCIPAL

Esta pantalla aparece despues de la bienvenida y es el centro de navegacion 
principal antes de jugar.

   2.1. Funcionamiento General

   En el estado MENU, el jugador puede usar las teclas de arriba y abajo 
   para seleccionar una opcion y ENTER para confirmarla. Las opciones son 
   "Nuevo Juego" y "Salir".

   2.2. Logica de Renderizado

   El metodo drawMenuScreen (llamado desde paintComponent) se encarga de 
   dibujar las opciones y un selector > que indica la opcion activa, cuya 
   posicion depende de la variable commandNum.

   Archivo: Main/GamePanel.java
   Codigo de Renderizado: (Similar al de la version anterior, pero llamado 
   en el estado MENU)

   2.3. Manejo de Teclas y Opciones

   Archivo: Main/ManejadorTeclas.java
   Codigo de Manejo de Teclas:

      // Dentro de keyPressed
      else if (gp.gameState == GameState.MENU) {
          if (code == KeyEvent.VK_W || code == KeyEvent.VK_UP) {
              gp.commandNum--;
              if (gp.commandNum < 0) { gp.commandNum = 1; }
          }
          if (code == KeyEvent.VK_S || code == KeyEvent.VK_DOWN) {
              gp.commandNum++;
              if (gp.commandNum > 1) { gp.commandNum = 0; }
          }
          if (code == KeyEvent.VK_ENTER) {
              switch (gp.commandNum) {
                  case 0: // Opcion "NUEVO JUEGO"
                      gp.gameState = GameState.PLAY;
                      // Opcional: llamar a un metodo gp.setupGame() para 
                      // inicializar todo.
                      break;
                  case 1: // Opcion "SALIR"
                      System.exit(0);
                      break;
              }
          }
      }

================================================================================

3. PANTALLA DE PAUSA (TECLA ESC)

Esta pantalla se activa al presionar ESC durante el juego (PLAY state), 
congelando la accion y mostrando un menu con varias opciones.

   3.1. Funcionamiento General

   Al cambiar al estado PAUSE, el bucle de actualizacion del juego se salta, 
   pero el de renderizado continua. Se dibuja el menu de pausa sobre la 
   pantalla del juego congelada. El jugador navega por este menu de forma 
   similar al menu principal.

   3.2. Logica de Renderizado

   Archivo: Main/GamePanel.java
   Codigo de Renderizado:

      // En paintComponent
      else if (gameState == GameState.PAUSE) {
          // Es importante que la logica de renderizado del juego se ejecute
          // para que la pantalla de pausa se muestre sobre el juego congelado.
          // ... dibujar el juego ...
          drawPauseScreen(g2); // Dibujar el menu de pausa encima
      }

      public void drawPauseScreen(Graphics2D g2) {
          // Fondo semitransparente para oscurecer el juego
          g2.setColor(new Color(0, 0, 0, 150));
          g2.fillRect(0, 0, screenWidth, screenHeight);

          g2.setFont(g2.getFont().deriveFont(Font.BOLD, 50F));
          g2.setColor(Color.WHITE);

          // Opciones del menu de pausa
          String options = {"Reanudar", "Reiniciar", "Menu Principal", "Salir"};
          int y = screenHeight / 2 - (tileSize  2);

          for (int i = 0; i < options.length; i++) {
              String text = optionsi;
              int x = getXforCenteredText(text, g2);
              g2.drawString(text, x, y + (i  tileSize  2));
              if (commandNum == i) {
                  g2.drawString(">", x - tileSize, y + (i  tileSize  2));
              }
          }
      }

   3.3. Manejo de Teclas y Opciones

   Archivo: Main/ManejadorTeclas.java
   Codigo de Manejo de Teclas:

      // Dentro de keyPressed
      else if (gp.gameState == GameState.PAUSE) {
          // Navegacion
          if (code == KeyEvent.VK_W || code == KeyEvent.VK_UP) {
              gp.commandNum--;
              if (gp.commandNum < 0) { gp.commandNum = 3; } // 4 opciones (0-3)
          }
          if (code == KeyEvent.VK_S || code == KeyEvent.VK_DOWN) {
              gp.commandNum++;
              if (gp.commandNum > 3) { gp.commandNum = 0; }
          }
          if (code == KeyEvent.VK_ENTER) {
              switch (gp.commandNum) {
                  case 0: // Reanudar
                      gp.gameState = GameState.PLAY;
                      break;
                  case 1: // Reiniciar
                      // Llamada al metodo de reinicio del GameEngine
                      gp.getGameEngine().reiniciarJuego();
                      gp.gameState = GameState.PLAY;
                      break;
                  case 2: // Menu Principal
                      gp.gameState = GameState.MENU;
                      gp.commandNum = 0; // Resetea el cursor del menu principal
                      break;
                  case 3: // Salir
                      System.exit(0);
                      break;
              }
          }
          // Tambien permitir salir de la pausa con ESC
          if (code == KeyEvent.VK_ESCAPE) {
              gp.gameState = GameState.PLAY;
          }
      }

================================================================================

4. IMPLEMENTACION COMPLETA DE LA FUNCION REINICIAR JUEGO

Esta seccion detalla la implementacion completa de la funcionalidad de 
reiniciar el juego desde el menu de pausa, incluyendo el reinicio de todas 
las estadisticas del jugador y el estado del mundo.

   4.1. Funcionamiento General

   La opcion "Reiniciar" (opcion 2 en el menu de pausa) permite al jugador 
   resetear completamente el juego a su estado inicial sin tener que cerrar 
   y volver a abrir la aplicacion. Esto incluye:

      - Reiniciar todas las estadisticas del jugador
      - Regenerar el mundo (chunks y tiles)
      - Limpiar y regenerar enemigos
      - Limpiar items consumibles
      - Resetear la posicion de la camara

   4.2. Arquitectura de la Solucion

   La funcionalidad de reinicio se implementa siguiendo la arquitectura del 
   juego:

      1. GamePanel.java (Main): Maneja el estado del menu de pausa y llama 
         al metodo de reinicio
      2. GameEngine.java (Domain): Contiene la logica central de reinicio
      3. JugadorSystem.java (Domain): Reinicia estadisticas especificas del 
         jugador
      4. ManejadorMapaInfinito.java (Domain): Reinicia chunks y items del 
         mapa

   4.3. Implementacion en GamePanel

      4.3.1. Flujo de Control en el Menu de Pausa

      Archivo: Main/GamePanel.java
      Metodo: actualizar() en el case MENU_PAUSA

         case MENU_PAUSA:
             if (inputService.isTecla1()) {
                 // Reanudar juego
                 estadoJuego = GameState.JUGANDO;
                 inputService.setTecla1(false);
             } else if (inputService.isTecla2()) {
                 //  REINICIAR JUEGO 
                 gameEngine.reiniciarJuego();
                 estadoJuego = GameState.JUGANDO;
                 inputService.setTecla2(false);
             } else if (inputService.isTecla3()) {
                 // Volver al menu principal
                 estadoJuego = GameState.MENU_PRINCIPAL;
                 inputService.setTecla3(false);
             } else if (inputService.isTeclaEscape()) {
                 // Volver al juego (reanudar)
                 estadoJuego = GameState.JUGANDO;
                 inputService.setTeclaEscape(false);
             }
             break;

      Nota: En esta implementacion, el menu de pausa usa teclas numericas 
      (1, 2, 3) para seleccionar opciones directamente, en lugar de un 
      cursor de navegacion.

   4.4. Implementacion del Metodo reiniciarJuego()

      4.4.1. Archivo: domain/GameEngine.java

      El metodo reiniciarJuego() es el corazon de la funcionalidad de 
      reinicio. Se encarga de coordinar el reinicio de todos los sistemas 
      del juego.

         public void reiniciarJuego() {
             // ========================================
             // 1. REINICIAR ESTADISTICAS DEL JUGADOR
             // ========================================
             
             // Vida maxima
             jugadorSystem.getJugador().setVida(100);
             
             // Arsenal de pociones
             jugadorSystem.setPocionesEnArsenal(0);
             
             // Acertijos resueltos
             jugadorSystem.setAcertijosResueltos(0);
             
             // Cooldown de danio (evita danio inmediato despues del reinicio)
             jugadorSystem.reiniciarCooldownDanio();
             
             // ========================================
             // 2. REINICIAR POSICION DEL JUGADOR
             // ========================================
             
             // Volver a la posicion inicial del mundo
             jugadorSystem.getMovimientoSystem().setMundoX(5000);
             jugadorSystem.getMovimientoSystem().setMundoY(5000);
             
             // ========================================
             // 3. REINICIAR ESTADOS DE MODALES Y COFRES
             // ========================================
             
             // Cerrar todos los modales activos
             modalCofreActivo = false;
             modalRespuestaCorrectaActivo = false;
             modalRespuestaIncorrectaActivo = false;
             
             // Resetear estados de cofres
             cofreYaActivado = false;
             cofreBloqueado = false;
             acertijoActual = null;
             cofreTileX = -1;
             cofreTileY = -1;
             
             // ========================================
             // 4. REINICIAR ENEMIGOS
             // ========================================
             
             // Limpiar lista de enemigos existentes
             enemigoSystem.getEnemigos().clear();
             
             // Generar nueva poblacion de enemigos alrededor del jugador
             enemigoSystem.generarEnemigosIniciales(
                 jugadorSystem.getMundoX(), 
                 jugadorSystem.getMundoY(), 
                 5  // Cantidad inicial de enemigos
             );
             
             // ========================================
             // 5. REINICIAR ITEMS CONSUMIBLES
             // ========================================
             
             // Eliminar todos los items (pociones, venenos) del mapa
             mapaInfinito.getItemsConsumibles().clear();
             
             // ========================================
             // 6. REINICIAR CHUNKS DEL MAPA
             // ========================================
             
             // Limpiar chunks cargados para forzar regeneracion
             mapaInfinito.reiniciarChunks();
             
             // ========================================
             // 7. ACTUALIZAR CAMARA Y GENERAR MUNDO
             // ========================================
             
             // Centrar camara en la nueva posicion del jugador
             camaraSystem.seguirEntidad(
                 jugadorSystem.getMundoX(), 
                 jugadorSystem.getMundoY()
             );
             
             // Generar chunks alrededor de la posicion inicial
             if (mapaAdapter != null) {
                 mapaAdapter.actualizarChunksActivos(
                     jugadorSystem.getMundoX(), 
                     jugadorSystem.getMundoY()
                 );
             } else if (mapaInfinito != null) {
                 mapaInfinito.actualizarChunksActivos(
                     jugadorSystem.getMundoX(), 
                     jugadorSystem.getMundoY()
                 );
             }
             
             // ========================================
             // 8. REACTIVAR EL JUEGO
             // ========================================
             
             jugando = true;
         }

   4.5. Metodos Auxiliares Implementados

      4.5.1. Metodo reiniciarCooldownDanio() en JugadorSystem

      Este metodo reinicia el temporizador que controla cuando el jugador 
      puede recibir danio nuevamente.

      Archivo: domain/JugadorSystem.java

         public void reiniciarCooldownDanio() {
             this.ultimoTiempoDanio = 0;
         }

      Proposito: Evitar que el jugador reciba danio inmediatamente despues 
      de reiniciar si hay un enemigo cerca. El cooldown se resetea a 0, 
      permitiendo un nuevo ciclo de danio desde el inicio.

      4.5.2. Metodo reiniciarChunks() en ManejadorMapaInfinito

      Este metodo limpia todos los chunks del mapa y los items consumibles, 
      forzando la regeneracion del mundo.

      Archivo: domain/ManejadorMapaInfinito.java

         public void reiniciarChunks() {
             // Limpiar HashMap de chunks activos
             chunksActivos.clear();
             
             // Limpiar lista de items consumibles
             itemsConsumibles.clear();
         }

      Proposito: 

         - chunksActivos.clear(): Elimina todos los chunks generados del 
           HashMap. Cuando el jugador se mueva despues del reinicio, los 
           chunks se regeneraran proceduralmente con el seed del mundo.

         - itemsConsumibles.clear(): Elimina todas las pociones y venenos 
           que el jugador no recogio. Nuevos items se generaran en los 
           nuevos chunks.

   4.6. Flujo Completo de Ejecucion

      1. Jugador presiona ESC durante el juego

      2. GamePanel cambia estado a MENU_PAUSA

      3. Se renderiza el menu con opciones:
         1 Reanudar
         2 Reiniciar  (Opcion de reinicio)
         3 Menu Principal
         ESC Volver

      4. Jugador presiona tecla 2

      5. GamePanel llama a gameEngine.reiniciarJuego()

      6. GameEngine ejecuta secuencia de reinicio:
         a. Reinicia estadisticas del jugador
         b. Resetea posicion del jugador
         c. Cierra modales activos
         d. Limpia y regenera enemigos
         e. Limpia items del mapa
         f. Reinicia chunks del mundo
         g. Actualiza camara
         h. Genera nuevo entorno

      7. GamePanel cambia estado a JUGANDO

      8. El juego continua desde el estado inicial

   4.7. Elementos que se Mantienen

   Algunos elementos del juego NO se reinician, manteniendo la continuidad 
   de la sesion:

      - Seed del mundo: El mundo se regenera con el mismo seed, creando el 
        mismo terreno
      - Configuracion del juego: FPS, tamanio de tiles, dimensiones de 
        pantalla
      - Teclas de control: Las configuraciones de InputService permanecen
      - Ventana del juego: La ventana JFrame no se cierra ni se recrea

   4.8. Elementos que SI se Reinician

   Lista completa de elementos que vuelven a su estado inicial:

      Elemento                      Valor Inicial           Ubicacion
      -------------------------------------------------------------------
      Vida del jugador              100                     JugadorSystem.jugador.vida
      Pociones en arsenal           0                       JugadorSystem.pocionesEnArsenal
      Acertijos resueltos           0                       JugadorSystem.acertijosResueltos
      Cooldown de danio             0                       JugadorSystem.ultimoTiempoDanio
      Posicion X del jugador        5000                    MovimientoSystem.mundoX
      Posicion Y del jugador        5000                    MovimientoSystem.mundoY
      Lista de enemigos             Vacia (5 nuevos)        EnemigoSystem.enemigos
      Items consumibles             Vacia                   MapaInfinito.itemsConsumibles
      Chunks del mapa               Vacio (Regenerados)     MapaInfinito.chunksActivos
      Modal de cofre                false                   GameEngine.modalCofreActivo
      Modal respuesta correcta      false                   GameEngine.modalRespuestaCorrectaActivo
      Modal respuesta incorrecta    false                   GameEngine.modalRespuestaIncorrectaActivo
      Acertijo actual               null                    GameEngine.acertijoActual
      Estado cofre activado         false                   GameEngine.cofreYaActivado
      Estado cofre bloqueado        false                   GameEngine.cofreBloqueado

   4.9. Consideraciones de Implementacion

      4.9.1. Orden de Reinicio

      El orden en que se reinician los componentes es importante:

         1. Primero: Estadisticas del jugador (no dependen de nada)
         2. Segundo: Posicion del jugador (necesaria para regenerar enemigos)
         3. Tercero: Estados de UI (modales)
         4. Cuarto: Enemigos (necesitan posicion del jugador)
         5. Quinto: Mapa e items (regeneracion completa)
         6. Sexto: Camara (necesita posicion del jugador)
         7. Ultimo: Reactivar el juego

      4.9.2. Regeneracion Procedural

      Gracias a que el mundo usa generacion procedural con seed:

         - Los chunks se regeneraran con el mismo terreno
         - Los cofres apareceran en las mismas posiciones
         - Los acertijos de los cofres se pueden resolver nuevamente
         - Los items se regeneraran en nuevas posiciones aleatorias

      4.9.3. Prevencion de Bugs

      La implementacion incluye varias medidas para prevenir bugs:

         - Reseteo del cooldown: Evita danio instantaneo al reiniciar
         - Limpieza de enemigos antes de regenerar: Previene duplicados
         - Limpieza de chunks antes de actualizar: Fuerza regeneracion completa
         - Cierre de modales: Evita que modales antiguos se muestren
         - Reseteo de flags de cofres: Permite reinteractuar con cofres

   4.10. Pruebas y Validacion

   Para verificar que el reinicio funciona correctamente:

      1. Iniciar juego y recoger pociones
      2. Recibir danio de enemigos
      3. Resolver acertijos
      4. Presionar ESC y seleccionar Reiniciar
      5. Verificar que la vida vuelve a 100
      6. Verificar que las pociones vuelven a 0
      7. Verificar que los acertijos resueltos vuelven a 0
      8. Verificar que la posicion del jugador es (5000, 5000)
      9. Verificar que hay nuevos enemigos
      10. Verificar que los cofres se pueden abrir nuevamente

   4.11. Posibles Extensiones Futuras

   Mejoras que se podrian implementar en el futuro:

      - Confirmacion de reinicio: Pedir confirmacion antes de reiniciar
      - Multiples slots de guardado: Permitir reiniciar a diferentes estados
      - Reinicio parcial: Opcion para mantener algunas estadisticas
      - Animacion de transicion: Efecto visual al reiniciar
      - Estadisticas persistentes: Guardar records entre reinicios

================================================================================